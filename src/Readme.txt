1. SummationPrinting

2. TwoPointer   -> twoPointerWithoutDuplicates(int[], int);
                -> twoPointerWithDuplicates(int[],target);
                -> twoPointerInwards(int[]);
                -> twoPointerOutwards(int[]);
                -> DNFSort(int[]);

                -> if possible add LinkedList fast & slow pointer here.


3. BinarySearch -> BinarySearch(int[],int);
                -> searchFirstPos(int[],int);
                -> searchLastPos(int[],int);
                -> searchInsertPosition(int[],int);
                -> findPeakElement(int[]); -> Bitonic array
                -> rotatedSortedArray(int[],int); -> pending
                -> Sqrt(x)


4. Sorting      -> Insertion
                -> MergeSort
                -> QuickSort


5. Sliding Window
There are 5 problems that comes under this pattern (see later)

6. Linked List (Do later)

7. Recursion.Recursion
        2 Branches:
                -> LeftRootRight(int); - Basic version
                -> LeftRootRight(String,int,List<String>); - Sequence pattern
                -> LeftRootRight(ArrayList<Character>,int,List<ArrayList<Character>>); - sequence pattern
                -> generateParanthesis(String,int,...);
                -> generateParanthesis(ArrayList<Character>,int,...);
                -> subsequence(int[],String,int,...);
                -> subsequence(int[],ArrayList<Character>,int,...);

        Binary Trees:
                -> LeftRootRight(int); - Basic version
                -> validateBST();
                -> hasPathSum();
                -> BTInOrderPostOrder();
                -> SortedArrayToBST();
                -> minimumDepthOfBT();
                -> BTMaximumPathSum();
                -> balancedBT();
                -> isSymmetric();

        n Branches:
                -> Permutations();
                -> PermutationsWithRepInput();

Topics from revision guide:

* LinkedList
* Sliding Window
* Binary Search
* Recursion.Recursion
* Backtracking
* BFS, DFS
* Dynamic Programming
* Trees
* Graphs
* Topological Sorting
* Greedy Algorithms
* Priority Queue
* Tries
